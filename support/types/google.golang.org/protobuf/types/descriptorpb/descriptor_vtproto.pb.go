// Code generated by protoc-gen-go-vtproto-builtins. DO NOT EDIT.
// protoc-gen-go-vtproto-builtins version: (devel)
// source: google/protobuf/descriptor.proto

package descriptorpb

import (
	binary "encoding/binary"
	fmt "fmt"
	proto "google.golang.org/protobuf/proto"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	io "io"
	math "math"
	bits "math/bits"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func CloneVT_FileDescriptorSet(m *descriptorpb.FileDescriptorSet) *descriptorpb.FileDescriptorSet {
	if m == nil {
		return (*descriptorpb.FileDescriptorSet)(nil)
	}
	r := &descriptorpb.FileDescriptorSet{}
	if rhs := m.File; rhs != nil {
		tmpContainer := make([]*descriptorpb.FileDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_FileDescriptorProto(v)
		}
		r.File = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_FileDescriptorProto(m *descriptorpb.FileDescriptorProto) *descriptorpb.FileDescriptorProto {
	if m == nil {
		return (*descriptorpb.FileDescriptorProto)(nil)
	}
	r := &descriptorpb.FileDescriptorProto{
		Options:        CloneVT_FileOptions(m.Options),
		SourceCodeInfo: CloneVT_SourceCodeInfo(m.SourceCodeInfo),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Package; rhs != nil {
		tmpVal := *rhs
		r.Package = &tmpVal
	}
	if rhs := m.Dependency; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.Dependency = tmpContainer
	}
	if rhs := m.PublicDependency; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.PublicDependency = tmpContainer
	}
	if rhs := m.WeakDependency; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.WeakDependency = tmpContainer
	}
	if rhs := m.MessageType; rhs != nil {
		tmpContainer := make([]*descriptorpb.DescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_DescriptorProto(v)
		}
		r.MessageType = tmpContainer
	}
	if rhs := m.EnumType; rhs != nil {
		tmpContainer := make([]*descriptorpb.EnumDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_EnumDescriptorProto(v)
		}
		r.EnumType = tmpContainer
	}
	if rhs := m.Service; rhs != nil {
		tmpContainer := make([]*descriptorpb.ServiceDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_ServiceDescriptorProto(v)
		}
		r.Service = tmpContainer
	}
	if rhs := m.Extension; rhs != nil {
		tmpContainer := make([]*descriptorpb.FieldDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_FieldDescriptorProto(v)
		}
		r.Extension = tmpContainer
	}
	if rhs := m.Syntax; rhs != nil {
		tmpVal := *rhs
		r.Syntax = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_DescriptorProto_ExtensionRange(m *descriptorpb.DescriptorProto_ExtensionRange) *descriptorpb.DescriptorProto_ExtensionRange {
	if m == nil {
		return (*descriptorpb.DescriptorProto_ExtensionRange)(nil)
	}
	r := &descriptorpb.DescriptorProto_ExtensionRange{
		Options: CloneVT_ExtensionRangeOptions(m.Options),
	}
	if rhs := m.Start; rhs != nil {
		tmpVal := *rhs
		r.Start = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_DescriptorProto_ReservedRange(m *descriptorpb.DescriptorProto_ReservedRange) *descriptorpb.DescriptorProto_ReservedRange {
	if m == nil {
		return (*descriptorpb.DescriptorProto_ReservedRange)(nil)
	}
	r := &descriptorpb.DescriptorProto_ReservedRange{}
	if rhs := m.Start; rhs != nil {
		tmpVal := *rhs
		r.Start = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_DescriptorProto(m *descriptorpb.DescriptorProto) *descriptorpb.DescriptorProto {
	if m == nil {
		return (*descriptorpb.DescriptorProto)(nil)
	}
	r := &descriptorpb.DescriptorProto{
		Options: CloneVT_MessageOptions(m.Options),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Field; rhs != nil {
		tmpContainer := make([]*descriptorpb.FieldDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_FieldDescriptorProto(v)
		}
		r.Field = tmpContainer
	}
	if rhs := m.Extension; rhs != nil {
		tmpContainer := make([]*descriptorpb.FieldDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_FieldDescriptorProto(v)
		}
		r.Extension = tmpContainer
	}
	if rhs := m.NestedType; rhs != nil {
		tmpContainer := make([]*descriptorpb.DescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_DescriptorProto(v)
		}
		r.NestedType = tmpContainer
	}
	if rhs := m.EnumType; rhs != nil {
		tmpContainer := make([]*descriptorpb.EnumDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_EnumDescriptorProto(v)
		}
		r.EnumType = tmpContainer
	}
	if rhs := m.ExtensionRange; rhs != nil {
		tmpContainer := make([]*descriptorpb.DescriptorProto_ExtensionRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_DescriptorProto_ExtensionRange(v)
		}
		r.ExtensionRange = tmpContainer
	}
	if rhs := m.OneofDecl; rhs != nil {
		tmpContainer := make([]*descriptorpb.OneofDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_OneofDescriptorProto(v)
		}
		r.OneofDecl = tmpContainer
	}
	if rhs := m.ReservedRange; rhs != nil {
		tmpContainer := make([]*descriptorpb.DescriptorProto_ReservedRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_DescriptorProto_ReservedRange(v)
		}
		r.ReservedRange = tmpContainer
	}
	if rhs := m.ReservedName; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.ReservedName = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_ExtensionRangeOptions(m *descriptorpb.ExtensionRangeOptions) *descriptorpb.ExtensionRangeOptions {
	if m == nil {
		return (*descriptorpb.ExtensionRangeOptions)(nil)
	}
	r := &descriptorpb.ExtensionRangeOptions{}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_FieldDescriptorProto(m *descriptorpb.FieldDescriptorProto) *descriptorpb.FieldDescriptorProto {
	if m == nil {
		return (*descriptorpb.FieldDescriptorProto)(nil)
	}
	r := &descriptorpb.FieldDescriptorProto{
		Options: CloneVT_FieldOptions(m.Options),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Number; rhs != nil {
		tmpVal := *rhs
		r.Number = &tmpVal
	}
	if rhs := m.Label; rhs != nil {
		tmpVal := *rhs
		r.Label = &tmpVal
	}
	if rhs := m.Type; rhs != nil {
		tmpVal := *rhs
		r.Type = &tmpVal
	}
	if rhs := m.TypeName; rhs != nil {
		tmpVal := *rhs
		r.TypeName = &tmpVal
	}
	if rhs := m.Extendee; rhs != nil {
		tmpVal := *rhs
		r.Extendee = &tmpVal
	}
	if rhs := m.DefaultValue; rhs != nil {
		tmpVal := *rhs
		r.DefaultValue = &tmpVal
	}
	if rhs := m.OneofIndex; rhs != nil {
		tmpVal := *rhs
		r.OneofIndex = &tmpVal
	}
	if rhs := m.JsonName; rhs != nil {
		tmpVal := *rhs
		r.JsonName = &tmpVal
	}
	if rhs := m.Proto3Optional; rhs != nil {
		tmpVal := *rhs
		r.Proto3Optional = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_OneofDescriptorProto(m *descriptorpb.OneofDescriptorProto) *descriptorpb.OneofDescriptorProto {
	if m == nil {
		return (*descriptorpb.OneofDescriptorProto)(nil)
	}
	r := &descriptorpb.OneofDescriptorProto{
		Options: CloneVT_OneofOptions(m.Options),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_EnumDescriptorProto_EnumReservedRange(m *descriptorpb.EnumDescriptorProto_EnumReservedRange) *descriptorpb.EnumDescriptorProto_EnumReservedRange {
	if m == nil {
		return (*descriptorpb.EnumDescriptorProto_EnumReservedRange)(nil)
	}
	r := &descriptorpb.EnumDescriptorProto_EnumReservedRange{}
	if rhs := m.Start; rhs != nil {
		tmpVal := *rhs
		r.Start = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_EnumDescriptorProto(m *descriptorpb.EnumDescriptorProto) *descriptorpb.EnumDescriptorProto {
	if m == nil {
		return (*descriptorpb.EnumDescriptorProto)(nil)
	}
	r := &descriptorpb.EnumDescriptorProto{
		Options: CloneVT_EnumOptions(m.Options),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Value; rhs != nil {
		tmpContainer := make([]*descriptorpb.EnumValueDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_EnumValueDescriptorProto(v)
		}
		r.Value = tmpContainer
	}
	if rhs := m.ReservedRange; rhs != nil {
		tmpContainer := make([]*descriptorpb.EnumDescriptorProto_EnumReservedRange, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_EnumDescriptorProto_EnumReservedRange(v)
		}
		r.ReservedRange = tmpContainer
	}
	if rhs := m.ReservedName; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.ReservedName = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_EnumValueDescriptorProto(m *descriptorpb.EnumValueDescriptorProto) *descriptorpb.EnumValueDescriptorProto {
	if m == nil {
		return (*descriptorpb.EnumValueDescriptorProto)(nil)
	}
	r := &descriptorpb.EnumValueDescriptorProto{
		Options: CloneVT_EnumValueOptions(m.Options),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Number; rhs != nil {
		tmpVal := *rhs
		r.Number = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_ServiceDescriptorProto(m *descriptorpb.ServiceDescriptorProto) *descriptorpb.ServiceDescriptorProto {
	if m == nil {
		return (*descriptorpb.ServiceDescriptorProto)(nil)
	}
	r := &descriptorpb.ServiceDescriptorProto{
		Options: CloneVT_ServiceOptions(m.Options),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.Method; rhs != nil {
		tmpContainer := make([]*descriptorpb.MethodDescriptorProto, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_MethodDescriptorProto(v)
		}
		r.Method = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_MethodDescriptorProto(m *descriptorpb.MethodDescriptorProto) *descriptorpb.MethodDescriptorProto {
	if m == nil {
		return (*descriptorpb.MethodDescriptorProto)(nil)
	}
	r := &descriptorpb.MethodDescriptorProto{
		Options: CloneVT_MethodOptions(m.Options),
	}
	if rhs := m.Name; rhs != nil {
		tmpVal := *rhs
		r.Name = &tmpVal
	}
	if rhs := m.InputType; rhs != nil {
		tmpVal := *rhs
		r.InputType = &tmpVal
	}
	if rhs := m.OutputType; rhs != nil {
		tmpVal := *rhs
		r.OutputType = &tmpVal
	}
	if rhs := m.ClientStreaming; rhs != nil {
		tmpVal := *rhs
		r.ClientStreaming = &tmpVal
	}
	if rhs := m.ServerStreaming; rhs != nil {
		tmpVal := *rhs
		r.ServerStreaming = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_FileOptions(m *descriptorpb.FileOptions) *descriptorpb.FileOptions {
	if m == nil {
		return (*descriptorpb.FileOptions)(nil)
	}
	r := &descriptorpb.FileOptions{}
	if rhs := m.JavaPackage; rhs != nil {
		tmpVal := *rhs
		r.JavaPackage = &tmpVal
	}
	if rhs := m.JavaOuterClassname; rhs != nil {
		tmpVal := *rhs
		r.JavaOuterClassname = &tmpVal
	}
	if rhs := m.JavaMultipleFiles; rhs != nil {
		tmpVal := *rhs
		r.JavaMultipleFiles = &tmpVal
	}
	if rhs := m.JavaGenerateEqualsAndHash; rhs != nil {
		tmpVal := *rhs
		r.JavaGenerateEqualsAndHash = &tmpVal
	}
	if rhs := m.JavaStringCheckUtf8; rhs != nil {
		tmpVal := *rhs
		r.JavaStringCheckUtf8 = &tmpVal
	}
	if rhs := m.OptimizeFor; rhs != nil {
		tmpVal := *rhs
		r.OptimizeFor = &tmpVal
	}
	if rhs := m.GoPackage; rhs != nil {
		tmpVal := *rhs
		r.GoPackage = &tmpVal
	}
	if rhs := m.CcGenericServices; rhs != nil {
		tmpVal := *rhs
		r.CcGenericServices = &tmpVal
	}
	if rhs := m.JavaGenericServices; rhs != nil {
		tmpVal := *rhs
		r.JavaGenericServices = &tmpVal
	}
	if rhs := m.PyGenericServices; rhs != nil {
		tmpVal := *rhs
		r.PyGenericServices = &tmpVal
	}
	if rhs := m.PhpGenericServices; rhs != nil {
		tmpVal := *rhs
		r.PhpGenericServices = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.CcEnableArenas; rhs != nil {
		tmpVal := *rhs
		r.CcEnableArenas = &tmpVal
	}
	if rhs := m.ObjcClassPrefix; rhs != nil {
		tmpVal := *rhs
		r.ObjcClassPrefix = &tmpVal
	}
	if rhs := m.CsharpNamespace; rhs != nil {
		tmpVal := *rhs
		r.CsharpNamespace = &tmpVal
	}
	if rhs := m.SwiftPrefix; rhs != nil {
		tmpVal := *rhs
		r.SwiftPrefix = &tmpVal
	}
	if rhs := m.PhpClassPrefix; rhs != nil {
		tmpVal := *rhs
		r.PhpClassPrefix = &tmpVal
	}
	if rhs := m.PhpNamespace; rhs != nil {
		tmpVal := *rhs
		r.PhpNamespace = &tmpVal
	}
	if rhs := m.PhpMetadataNamespace; rhs != nil {
		tmpVal := *rhs
		r.PhpMetadataNamespace = &tmpVal
	}
	if rhs := m.RubyPackage; rhs != nil {
		tmpVal := *rhs
		r.RubyPackage = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_MessageOptions(m *descriptorpb.MessageOptions) *descriptorpb.MessageOptions {
	if m == nil {
		return (*descriptorpb.MessageOptions)(nil)
	}
	r := &descriptorpb.MessageOptions{}
	if rhs := m.MessageSetWireFormat; rhs != nil {
		tmpVal := *rhs
		r.MessageSetWireFormat = &tmpVal
	}
	if rhs := m.NoStandardDescriptorAccessor; rhs != nil {
		tmpVal := *rhs
		r.NoStandardDescriptorAccessor = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.MapEntry; rhs != nil {
		tmpVal := *rhs
		r.MapEntry = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_FieldOptions(m *descriptorpb.FieldOptions) *descriptorpb.FieldOptions {
	if m == nil {
		return (*descriptorpb.FieldOptions)(nil)
	}
	r := &descriptorpb.FieldOptions{}
	if rhs := m.Ctype; rhs != nil {
		tmpVal := *rhs
		r.Ctype = &tmpVal
	}
	if rhs := m.Packed; rhs != nil {
		tmpVal := *rhs
		r.Packed = &tmpVal
	}
	if rhs := m.Jstype; rhs != nil {
		tmpVal := *rhs
		r.Jstype = &tmpVal
	}
	if rhs := m.Lazy; rhs != nil {
		tmpVal := *rhs
		r.Lazy = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.Weak; rhs != nil {
		tmpVal := *rhs
		r.Weak = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_OneofOptions(m *descriptorpb.OneofOptions) *descriptorpb.OneofOptions {
	if m == nil {
		return (*descriptorpb.OneofOptions)(nil)
	}
	r := &descriptorpb.OneofOptions{}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_EnumOptions(m *descriptorpb.EnumOptions) *descriptorpb.EnumOptions {
	if m == nil {
		return (*descriptorpb.EnumOptions)(nil)
	}
	r := &descriptorpb.EnumOptions{}
	if rhs := m.AllowAlias; rhs != nil {
		tmpVal := *rhs
		r.AllowAlias = &tmpVal
	}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_EnumValueOptions(m *descriptorpb.EnumValueOptions) *descriptorpb.EnumValueOptions {
	if m == nil {
		return (*descriptorpb.EnumValueOptions)(nil)
	}
	r := &descriptorpb.EnumValueOptions{}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_ServiceOptions(m *descriptorpb.ServiceOptions) *descriptorpb.ServiceOptions {
	if m == nil {
		return (*descriptorpb.ServiceOptions)(nil)
	}
	r := &descriptorpb.ServiceOptions{}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_MethodOptions(m *descriptorpb.MethodOptions) *descriptorpb.MethodOptions {
	if m == nil {
		return (*descriptorpb.MethodOptions)(nil)
	}
	r := &descriptorpb.MethodOptions{}
	if rhs := m.Deprecated; rhs != nil {
		tmpVal := *rhs
		r.Deprecated = &tmpVal
	}
	if rhs := m.IdempotencyLevel; rhs != nil {
		tmpVal := *rhs
		r.IdempotencyLevel = &tmpVal
	}
	if rhs := m.UninterpretedOption; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption(v)
		}
		r.UninterpretedOption = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_UninterpretedOption_NamePart(m *descriptorpb.UninterpretedOption_NamePart) *descriptorpb.UninterpretedOption_NamePart {
	if m == nil {
		return (*descriptorpb.UninterpretedOption_NamePart)(nil)
	}
	r := &descriptorpb.UninterpretedOption_NamePart{}
	if rhs := m.NamePart; rhs != nil {
		tmpVal := *rhs
		r.NamePart = &tmpVal
	}
	if rhs := m.IsExtension; rhs != nil {
		tmpVal := *rhs
		r.IsExtension = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_UninterpretedOption(m *descriptorpb.UninterpretedOption) *descriptorpb.UninterpretedOption {
	if m == nil {
		return (*descriptorpb.UninterpretedOption)(nil)
	}
	r := &descriptorpb.UninterpretedOption{}
	if rhs := m.Name; rhs != nil {
		tmpContainer := make([]*descriptorpb.UninterpretedOption_NamePart, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_UninterpretedOption_NamePart(v)
		}
		r.Name = tmpContainer
	}
	if rhs := m.IdentifierValue; rhs != nil {
		tmpVal := *rhs
		r.IdentifierValue = &tmpVal
	}
	if rhs := m.PositiveIntValue; rhs != nil {
		tmpVal := *rhs
		r.PositiveIntValue = &tmpVal
	}
	if rhs := m.NegativeIntValue; rhs != nil {
		tmpVal := *rhs
		r.NegativeIntValue = &tmpVal
	}
	if rhs := m.DoubleValue; rhs != nil {
		tmpVal := *rhs
		r.DoubleValue = &tmpVal
	}
	if rhs := m.StringValue; rhs != nil {
		tmpBytes := make([]byte, len(rhs))
		copy(tmpBytes, rhs)
		r.StringValue = tmpBytes
	}
	if rhs := m.AggregateValue; rhs != nil {
		tmpVal := *rhs
		r.AggregateValue = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_SourceCodeInfo_Location(m *descriptorpb.SourceCodeInfo_Location) *descriptorpb.SourceCodeInfo_Location {
	if m == nil {
		return (*descriptorpb.SourceCodeInfo_Location)(nil)
	}
	r := &descriptorpb.SourceCodeInfo_Location{}
	if rhs := m.Path; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.Path = tmpContainer
	}
	if rhs := m.Span; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.Span = tmpContainer
	}
	if rhs := m.LeadingComments; rhs != nil {
		tmpVal := *rhs
		r.LeadingComments = &tmpVal
	}
	if rhs := m.TrailingComments; rhs != nil {
		tmpVal := *rhs
		r.TrailingComments = &tmpVal
	}
	if rhs := m.LeadingDetachedComments; rhs != nil {
		tmpContainer := make([]string, len(rhs))
		copy(tmpContainer, rhs)
		r.LeadingDetachedComments = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_SourceCodeInfo(m *descriptorpb.SourceCodeInfo) *descriptorpb.SourceCodeInfo {
	if m == nil {
		return (*descriptorpb.SourceCodeInfo)(nil)
	}
	r := &descriptorpb.SourceCodeInfo{}
	if rhs := m.Location; rhs != nil {
		tmpContainer := make([]*descriptorpb.SourceCodeInfo_Location, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_SourceCodeInfo_Location(v)
		}
		r.Location = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_GeneratedCodeInfo_Annotation(m *descriptorpb.GeneratedCodeInfo_Annotation) *descriptorpb.GeneratedCodeInfo_Annotation {
	if m == nil {
		return (*descriptorpb.GeneratedCodeInfo_Annotation)(nil)
	}
	r := &descriptorpb.GeneratedCodeInfo_Annotation{}
	if rhs := m.Path; rhs != nil {
		tmpContainer := make([]int32, len(rhs))
		copy(tmpContainer, rhs)
		r.Path = tmpContainer
	}
	if rhs := m.SourceFile; rhs != nil {
		tmpVal := *rhs
		r.SourceFile = &tmpVal
	}
	if rhs := m.Begin; rhs != nil {
		tmpVal := *rhs
		r.Begin = &tmpVal
	}
	if rhs := m.End; rhs != nil {
		tmpVal := *rhs
		r.End = &tmpVal
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_GeneratedCodeInfo(m *descriptorpb.GeneratedCodeInfo) *descriptorpb.GeneratedCodeInfo {
	if m == nil {
		return (*descriptorpb.GeneratedCodeInfo)(nil)
	}
	r := &descriptorpb.GeneratedCodeInfo{}
	if rhs := m.Annotation; rhs != nil {
		tmpContainer := make([]*descriptorpb.GeneratedCodeInfo_Annotation, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_GeneratedCodeInfo_Annotation(v)
		}
		r.Annotation = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func EqualVT_FileDescriptorSet(this *descriptorpb.FileDescriptorSet, that *descriptorpb.FileDescriptorSet) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.File) != len(that.File) {
		return false
	}
	for i, vx := range this.File {
		vy := that.File[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.FileDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.FileDescriptorProto{}
			}
			if !EqualVT_FileDescriptorProto(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_FileDescriptorProto(this *descriptorpb.FileDescriptorProto, that *descriptorpb.FileDescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Package, that.Package; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Dependency) != len(that.Dependency) {
		return false
	}
	for i, vx := range this.Dependency {
		vy := that.Dependency[i]
		if vx != vy {
			return false
		}
	}
	if len(this.MessageType) != len(that.MessageType) {
		return false
	}
	for i, vx := range this.MessageType {
		vy := that.MessageType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.DescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.DescriptorProto{}
			}
			if !EqualVT_DescriptorProto(p, q) {
				return false
			}
		}
	}
	if len(this.EnumType) != len(that.EnumType) {
		return false
	}
	for i, vx := range this.EnumType {
		vy := that.EnumType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.EnumDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.EnumDescriptorProto{}
			}
			if !EqualVT_EnumDescriptorProto(p, q) {
				return false
			}
		}
	}
	if len(this.Service) != len(that.Service) {
		return false
	}
	for i, vx := range this.Service {
		vy := that.Service[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.ServiceDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.ServiceDescriptorProto{}
			}
			if !EqualVT_ServiceDescriptorProto(p, q) {
				return false
			}
		}
	}
	if len(this.Extension) != len(that.Extension) {
		return false
	}
	for i, vx := range this.Extension {
		vy := that.Extension[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.FieldDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.FieldDescriptorProto{}
			}
			if !EqualVT_FieldDescriptorProto(p, q) {
				return false
			}
		}
	}
	if !EqualVT_FileOptions(this.Options, that.Options) {
		return false
	}
	if !EqualVT_SourceCodeInfo(this.SourceCodeInfo, that.SourceCodeInfo) {
		return false
	}
	if len(this.PublicDependency) != len(that.PublicDependency) {
		return false
	}
	for i, vx := range this.PublicDependency {
		vy := that.PublicDependency[i]
		if vx != vy {
			return false
		}
	}
	if len(this.WeakDependency) != len(that.WeakDependency) {
		return false
	}
	for i, vx := range this.WeakDependency {
		vy := that.WeakDependency[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.Syntax, that.Syntax; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_DescriptorProto_ExtensionRange(this *descriptorpb.DescriptorProto_ExtensionRange, that *descriptorpb.DescriptorProto_ExtensionRange) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Start, that.Start; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !EqualVT_ExtensionRangeOptions(this.Options, that.Options) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_DescriptorProto_ReservedRange(this *descriptorpb.DescriptorProto_ReservedRange, that *descriptorpb.DescriptorProto_ReservedRange) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Start, that.Start; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_DescriptorProto(this *descriptorpb.DescriptorProto, that *descriptorpb.DescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Field) != len(that.Field) {
		return false
	}
	for i, vx := range this.Field {
		vy := that.Field[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.FieldDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.FieldDescriptorProto{}
			}
			if !EqualVT_FieldDescriptorProto(p, q) {
				return false
			}
		}
	}
	if len(this.NestedType) != len(that.NestedType) {
		return false
	}
	for i, vx := range this.NestedType {
		vy := that.NestedType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.DescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.DescriptorProto{}
			}
			if !EqualVT_DescriptorProto(p, q) {
				return false
			}
		}
	}
	if len(this.EnumType) != len(that.EnumType) {
		return false
	}
	for i, vx := range this.EnumType {
		vy := that.EnumType[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.EnumDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.EnumDescriptorProto{}
			}
			if !EqualVT_EnumDescriptorProto(p, q) {
				return false
			}
		}
	}
	if len(this.ExtensionRange) != len(that.ExtensionRange) {
		return false
	}
	for i, vx := range this.ExtensionRange {
		vy := that.ExtensionRange[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.DescriptorProto_ExtensionRange{}
			}
			if q == nil {
				q = &descriptorpb.DescriptorProto_ExtensionRange{}
			}
			if !EqualVT_DescriptorProto_ExtensionRange(p, q) {
				return false
			}
		}
	}
	if len(this.Extension) != len(that.Extension) {
		return false
	}
	for i, vx := range this.Extension {
		vy := that.Extension[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.FieldDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.FieldDescriptorProto{}
			}
			if !EqualVT_FieldDescriptorProto(p, q) {
				return false
			}
		}
	}
	if !EqualVT_MessageOptions(this.Options, that.Options) {
		return false
	}
	if len(this.OneofDecl) != len(that.OneofDecl) {
		return false
	}
	for i, vx := range this.OneofDecl {
		vy := that.OneofDecl[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.OneofDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.OneofDescriptorProto{}
			}
			if !EqualVT_OneofDescriptorProto(p, q) {
				return false
			}
		}
	}
	if len(this.ReservedRange) != len(that.ReservedRange) {
		return false
	}
	for i, vx := range this.ReservedRange {
		vy := that.ReservedRange[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.DescriptorProto_ReservedRange{}
			}
			if q == nil {
				q = &descriptorpb.DescriptorProto_ReservedRange{}
			}
			if !EqualVT_DescriptorProto_ReservedRange(p, q) {
				return false
			}
		}
	}
	if len(this.ReservedName) != len(that.ReservedName) {
		return false
	}
	for i, vx := range this.ReservedName {
		vy := that.ReservedName[i]
		if vx != vy {
			return false
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_ExtensionRangeOptions(this *descriptorpb.ExtensionRangeOptions, that *descriptorpb.ExtensionRangeOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_FieldDescriptorProto(this *descriptorpb.FieldDescriptorProto, that *descriptorpb.FieldDescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Extendee, that.Extendee; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Number, that.Number; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Label, that.Label; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Type, that.Type; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.TypeName, that.TypeName; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DefaultValue, that.DefaultValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !EqualVT_FieldOptions(this.Options, that.Options) {
		return false
	}
	if p, q := this.OneofIndex, that.OneofIndex; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JsonName, that.JsonName; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Proto3Optional, that.Proto3Optional; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_OneofDescriptorProto(this *descriptorpb.OneofDescriptorProto, that *descriptorpb.OneofDescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !EqualVT_OneofOptions(this.Options, that.Options) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_EnumDescriptorProto_EnumReservedRange(this *descriptorpb.EnumDescriptorProto_EnumReservedRange, that *descriptorpb.EnumDescriptorProto_EnumReservedRange) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Start, that.Start; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_EnumDescriptorProto(this *descriptorpb.EnumDescriptorProto, that *descriptorpb.EnumDescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Value) != len(that.Value) {
		return false
	}
	for i, vx := range this.Value {
		vy := that.Value[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.EnumValueDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.EnumValueDescriptorProto{}
			}
			if !EqualVT_EnumValueDescriptorProto(p, q) {
				return false
			}
		}
	}
	if !EqualVT_EnumOptions(this.Options, that.Options) {
		return false
	}
	if len(this.ReservedRange) != len(that.ReservedRange) {
		return false
	}
	for i, vx := range this.ReservedRange {
		vy := that.ReservedRange[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.EnumDescriptorProto_EnumReservedRange{}
			}
			if q == nil {
				q = &descriptorpb.EnumDescriptorProto_EnumReservedRange{}
			}
			if !EqualVT_EnumDescriptorProto_EnumReservedRange(p, q) {
				return false
			}
		}
	}
	if len(this.ReservedName) != len(that.ReservedName) {
		return false
	}
	for i, vx := range this.ReservedName {
		vy := that.ReservedName[i]
		if vx != vy {
			return false
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_EnumValueDescriptorProto(this *descriptorpb.EnumValueDescriptorProto, that *descriptorpb.EnumValueDescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Number, that.Number; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !EqualVT_EnumValueOptions(this.Options, that.Options) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_ServiceDescriptorProto(this *descriptorpb.ServiceDescriptorProto, that *descriptorpb.ServiceDescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.Method) != len(that.Method) {
		return false
	}
	for i, vx := range this.Method {
		vy := that.Method[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.MethodDescriptorProto{}
			}
			if q == nil {
				q = &descriptorpb.MethodDescriptorProto{}
			}
			if !EqualVT_MethodDescriptorProto(p, q) {
				return false
			}
		}
	}
	if !EqualVT_ServiceOptions(this.Options, that.Options) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_MethodDescriptorProto(this *descriptorpb.MethodDescriptorProto, that *descriptorpb.MethodDescriptorProto) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Name, that.Name; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.InputType, that.InputType; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OutputType, that.OutputType; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if !EqualVT_MethodOptions(this.Options, that.Options) {
		return false
	}
	if p, q := this.ClientStreaming, that.ClientStreaming; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.ServerStreaming, that.ServerStreaming; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_FileOptions(this *descriptorpb.FileOptions, that *descriptorpb.FileOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.JavaPackage, that.JavaPackage; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaOuterClassname, that.JavaOuterClassname; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.OptimizeFor, that.OptimizeFor; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaMultipleFiles, that.JavaMultipleFiles; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.GoPackage, that.GoPackage; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.CcGenericServices, that.CcGenericServices; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaGenericServices, that.JavaGenericServices; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PyGenericServices, that.PyGenericServices; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaGenerateEqualsAndHash, that.JavaGenerateEqualsAndHash; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.JavaStringCheckUtf8, that.JavaStringCheckUtf8; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.CcEnableArenas, that.CcEnableArenas; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.ObjcClassPrefix, that.ObjcClassPrefix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.CsharpNamespace, that.CsharpNamespace; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.SwiftPrefix, that.SwiftPrefix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PhpClassPrefix, that.PhpClassPrefix; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PhpNamespace, that.PhpNamespace; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PhpGenericServices, that.PhpGenericServices; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PhpMetadataNamespace, that.PhpMetadataNamespace; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.RubyPackage, that.RubyPackage; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_MessageOptions(this *descriptorpb.MessageOptions, that *descriptorpb.MessageOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.MessageSetWireFormat, that.MessageSetWireFormat; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.NoStandardDescriptorAccessor, that.NoStandardDescriptorAccessor; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.MapEntry, that.MapEntry; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_FieldOptions(this *descriptorpb.FieldOptions, that *descriptorpb.FieldOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Ctype, that.Ctype; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Packed, that.Packed; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Lazy, that.Lazy; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Jstype, that.Jstype; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Weak, that.Weak; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_OneofOptions(this *descriptorpb.OneofOptions, that *descriptorpb.OneofOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_EnumOptions(this *descriptorpb.EnumOptions, that *descriptorpb.EnumOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.AllowAlias, that.AllowAlias; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_EnumValueOptions(this *descriptorpb.EnumValueOptions, that *descriptorpb.EnumValueOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_ServiceOptions(this *descriptorpb.ServiceOptions, that *descriptorpb.ServiceOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_MethodOptions(this *descriptorpb.MethodOptions, that *descriptorpb.MethodOptions) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.Deprecated, that.Deprecated; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.IdempotencyLevel, that.IdempotencyLevel; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.UninterpretedOption) != len(that.UninterpretedOption) {
		return false
	}
	for i, vx := range this.UninterpretedOption {
		vy := that.UninterpretedOption[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption{}
			}
			if !EqualVT_UninterpretedOption(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_UninterpretedOption_NamePart(this *descriptorpb.UninterpretedOption_NamePart, that *descriptorpb.UninterpretedOption_NamePart) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if p, q := this.NamePart, that.NamePart; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.IsExtension, that.IsExtension; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_UninterpretedOption(this *descriptorpb.UninterpretedOption, that *descriptorpb.UninterpretedOption) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Name) != len(that.Name) {
		return false
	}
	for i, vx := range this.Name {
		vy := that.Name[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.UninterpretedOption_NamePart{}
			}
			if q == nil {
				q = &descriptorpb.UninterpretedOption_NamePart{}
			}
			if !EqualVT_UninterpretedOption_NamePart(p, q) {
				return false
			}
		}
	}
	if p, q := this.IdentifierValue, that.IdentifierValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.PositiveIntValue, that.PositiveIntValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.NegativeIntValue, that.NegativeIntValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.DoubleValue, that.DoubleValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.StringValue, that.StringValue; (p == nil && q != nil) || (p != nil && q == nil) || string(p) != string(q) {
		return false
	}
	if p, q := this.AggregateValue, that.AggregateValue; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_SourceCodeInfo_Location(this *descriptorpb.SourceCodeInfo_Location, that *descriptorpb.SourceCodeInfo_Location) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Path) != len(that.Path) {
		return false
	}
	for i, vx := range this.Path {
		vy := that.Path[i]
		if vx != vy {
			return false
		}
	}
	if len(this.Span) != len(that.Span) {
		return false
	}
	for i, vx := range this.Span {
		vy := that.Span[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.LeadingComments, that.LeadingComments; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.TrailingComments, that.TrailingComments; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if len(this.LeadingDetachedComments) != len(that.LeadingDetachedComments) {
		return false
	}
	for i, vx := range this.LeadingDetachedComments {
		vy := that.LeadingDetachedComments[i]
		if vx != vy {
			return false
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_SourceCodeInfo(this *descriptorpb.SourceCodeInfo, that *descriptorpb.SourceCodeInfo) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Location) != len(that.Location) {
		return false
	}
	for i, vx := range this.Location {
		vy := that.Location[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.SourceCodeInfo_Location{}
			}
			if q == nil {
				q = &descriptorpb.SourceCodeInfo_Location{}
			}
			if !EqualVT_SourceCodeInfo_Location(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_GeneratedCodeInfo_Annotation(this *descriptorpb.GeneratedCodeInfo_Annotation, that *descriptorpb.GeneratedCodeInfo_Annotation) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Path) != len(that.Path) {
		return false
	}
	for i, vx := range this.Path {
		vy := that.Path[i]
		if vx != vy {
			return false
		}
	}
	if p, q := this.SourceFile, that.SourceFile; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.Begin, that.Begin; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	if p, q := this.End, that.End; (p == nil && q != nil) || (p != nil && (q == nil || *p != *q)) {
		return false
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_GeneratedCodeInfo(this *descriptorpb.GeneratedCodeInfo, that *descriptorpb.GeneratedCodeInfo) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Annotation) != len(that.Annotation) {
		return false
	}
	for i, vx := range this.Annotation {
		vy := that.Annotation[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &descriptorpb.GeneratedCodeInfo_Annotation{}
			}
			if q == nil {
				q = &descriptorpb.GeneratedCodeInfo_Annotation{}
			}
			if !EqualVT_GeneratedCodeInfo_Annotation(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func MarshalVT_FileDescriptorSet(m *descriptorpb.FileDescriptorSet) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_FileDescriptorSet(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_FileDescriptorSet(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_FileDescriptorSet(m *descriptorpb.FileDescriptorSet, dAtA []byte) (int, error) {
	size := SizeVT_FileDescriptorSet(m)
	return MarshalToSizedBufferVT_FileDescriptorSet(m, dAtA[:size])
}

func MarshalToSizedBufferVT_FileDescriptorSet(m *descriptorpb.FileDescriptorSet, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.File) > 0 {
		for iNdEx := len(m.File) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_FileDescriptorProto(m.File[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func MarshalVT_FileDescriptorProto(m *descriptorpb.FileDescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_FileDescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_FileDescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_FileDescriptorProto(m *descriptorpb.FileDescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_FileDescriptorProto(m)
	return MarshalToSizedBufferVT_FileDescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_FileDescriptorProto(m *descriptorpb.FileDescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.Syntax != nil {
		i -= len(*m.Syntax)
		copy(dAtA[i:], *m.Syntax)
		i = encodeVarint(dAtA, i, uint64(len(*m.Syntax)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.WeakDependency) > 0 {
		for iNdEx := len(m.WeakDependency) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.WeakDependency[iNdEx]))
			i--
			dAtA[i] = 0x58
		}
	}
	if len(m.PublicDependency) > 0 {
		for iNdEx := len(m.PublicDependency) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarint(dAtA, i, uint64(m.PublicDependency[iNdEx]))
			i--
			dAtA[i] = 0x50
		}
	}
	if m.SourceCodeInfo != nil {
		size, err := MarshalToSizedBufferVT_SourceCodeInfo(m.SourceCodeInfo, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x4a
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_FileOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_FieldDescriptorProto(m.Extension[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Service) > 0 {
		for iNdEx := len(m.Service) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_ServiceDescriptorProto(m.Service[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.EnumType) > 0 {
		for iNdEx := len(m.EnumType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_EnumDescriptorProto(m.EnumType[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.MessageType) > 0 {
		for iNdEx := len(m.MessageType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_DescriptorProto(m.MessageType[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Dependency) > 0 {
		for iNdEx := len(m.Dependency) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Dependency[iNdEx])
			copy(dAtA[i:], m.Dependency[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.Dependency[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Package != nil {
		i -= len(*m.Package)
		copy(dAtA[i:], *m.Package)
		i = encodeVarint(dAtA, i, uint64(len(*m.Package)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_DescriptorProto_ExtensionRange(m *descriptorpb.DescriptorProto_ExtensionRange) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_DescriptorProto_ExtensionRange(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_DescriptorProto_ExtensionRange(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_DescriptorProto_ExtensionRange(m *descriptorpb.DescriptorProto_ExtensionRange, dAtA []byte) (int, error) {
	size := SizeVT_DescriptorProto_ExtensionRange(m)
	return MarshalToSizedBufferVT_DescriptorProto_ExtensionRange(m, dAtA[:size])
}

func MarshalToSizedBufferVT_DescriptorProto_ExtensionRange(m *descriptorpb.DescriptorProto_ExtensionRange, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_ExtensionRangeOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.End != nil {
		i = encodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func MarshalVT_DescriptorProto_ReservedRange(m *descriptorpb.DescriptorProto_ReservedRange) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_DescriptorProto_ReservedRange(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_DescriptorProto_ReservedRange(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_DescriptorProto_ReservedRange(m *descriptorpb.DescriptorProto_ReservedRange, dAtA []byte) (int, error) {
	size := SizeVT_DescriptorProto_ReservedRange(m)
	return MarshalToSizedBufferVT_DescriptorProto_ReservedRange(m, dAtA[:size])
}

func MarshalToSizedBufferVT_DescriptorProto_ReservedRange(m *descriptorpb.DescriptorProto_ReservedRange, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.End != nil {
		i = encodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func MarshalVT_DescriptorProto(m *descriptorpb.DescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_DescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_DescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_DescriptorProto(m *descriptorpb.DescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_DescriptorProto(m)
	return MarshalToSizedBufferVT_DescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_DescriptorProto(m *descriptorpb.DescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.ReservedName) > 0 {
		for iNdEx := len(m.ReservedName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReservedName[iNdEx])
			copy(dAtA[i:], m.ReservedName[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.ReservedName[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ReservedRange) > 0 {
		for iNdEx := len(m.ReservedRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_DescriptorProto_ReservedRange(m.ReservedRange[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.OneofDecl) > 0 {
		for iNdEx := len(m.OneofDecl) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_OneofDescriptorProto(m.OneofDecl[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_MessageOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Extension) > 0 {
		for iNdEx := len(m.Extension) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_FieldDescriptorProto(m.Extension[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.ExtensionRange) > 0 {
		for iNdEx := len(m.ExtensionRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_DescriptorProto_ExtensionRange(m.ExtensionRange[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.EnumType) > 0 {
		for iNdEx := len(m.EnumType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_EnumDescriptorProto(m.EnumType[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NestedType) > 0 {
		for iNdEx := len(m.NestedType) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_DescriptorProto(m.NestedType[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Field) > 0 {
		for iNdEx := len(m.Field) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_FieldDescriptorProto(m.Field[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_ExtensionRangeOptions(m *descriptorpb.ExtensionRangeOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_ExtensionRangeOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_ExtensionRangeOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_ExtensionRangeOptions(m *descriptorpb.ExtensionRangeOptions, dAtA []byte) (int, error) {
	size := SizeVT_ExtensionRangeOptions(m)
	return MarshalToSizedBufferVT_ExtensionRangeOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_ExtensionRangeOptions(m *descriptorpb.ExtensionRangeOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func MarshalVT_FieldDescriptorProto(m *descriptorpb.FieldDescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_FieldDescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_FieldDescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_FieldDescriptorProto(m *descriptorpb.FieldDescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_FieldDescriptorProto(m)
	return MarshalToSizedBufferVT_FieldDescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_FieldDescriptorProto(m *descriptorpb.FieldDescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.Proto3Optional != nil {
		i--
		if *m.Proto3Optional {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.JsonName != nil {
		i -= len(*m.JsonName)
		copy(dAtA[i:], *m.JsonName)
		i = encodeVarint(dAtA, i, uint64(len(*m.JsonName)))
		i--
		dAtA[i] = 0x52
	}
	if m.OneofIndex != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OneofIndex))
		i--
		dAtA[i] = 0x48
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_FieldOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x42
	}
	if m.DefaultValue != nil {
		i -= len(*m.DefaultValue)
		copy(dAtA[i:], *m.DefaultValue)
		i = encodeVarint(dAtA, i, uint64(len(*m.DefaultValue)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TypeName != nil {
		i -= len(*m.TypeName)
		copy(dAtA[i:], *m.TypeName)
		i = encodeVarint(dAtA, i, uint64(len(*m.TypeName)))
		i--
		dAtA[i] = 0x32
	}
	if m.Type != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Label != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Label))
		i--
		dAtA[i] = 0x20
	}
	if m.Number != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x18
	}
	if m.Extendee != nil {
		i -= len(*m.Extendee)
		copy(dAtA[i:], *m.Extendee)
		i = encodeVarint(dAtA, i, uint64(len(*m.Extendee)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_OneofDescriptorProto(m *descriptorpb.OneofDescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_OneofDescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_OneofDescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_OneofDescriptorProto(m *descriptorpb.OneofDescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_OneofDescriptorProto(m)
	return MarshalToSizedBufferVT_OneofDescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_OneofDescriptorProto(m *descriptorpb.OneofDescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_OneofOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_EnumDescriptorProto_EnumReservedRange(m *descriptorpb.EnumDescriptorProto_EnumReservedRange) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_EnumDescriptorProto_EnumReservedRange(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_EnumDescriptorProto_EnumReservedRange(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_EnumDescriptorProto_EnumReservedRange(m *descriptorpb.EnumDescriptorProto_EnumReservedRange, dAtA []byte) (int, error) {
	size := SizeVT_EnumDescriptorProto_EnumReservedRange(m)
	return MarshalToSizedBufferVT_EnumDescriptorProto_EnumReservedRange(m, dAtA[:size])
}

func MarshalToSizedBufferVT_EnumDescriptorProto_EnumReservedRange(m *descriptorpb.EnumDescriptorProto_EnumReservedRange, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.End != nil {
		i = encodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func MarshalVT_EnumDescriptorProto(m *descriptorpb.EnumDescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_EnumDescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_EnumDescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_EnumDescriptorProto(m *descriptorpb.EnumDescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_EnumDescriptorProto(m)
	return MarshalToSizedBufferVT_EnumDescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_EnumDescriptorProto(m *descriptorpb.EnumDescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.ReservedName) > 0 {
		for iNdEx := len(m.ReservedName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReservedName[iNdEx])
			copy(dAtA[i:], m.ReservedName[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.ReservedName[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ReservedRange) > 0 {
		for iNdEx := len(m.ReservedRange) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_EnumDescriptorProto_EnumReservedRange(m.ReservedRange[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_EnumOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Value) > 0 {
		for iNdEx := len(m.Value) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_EnumValueDescriptorProto(m.Value[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_EnumValueDescriptorProto(m *descriptorpb.EnumValueDescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_EnumValueDescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_EnumValueDescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_EnumValueDescriptorProto(m *descriptorpb.EnumValueDescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_EnumValueDescriptorProto(m)
	return MarshalToSizedBufferVT_EnumValueDescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_EnumValueDescriptorProto(m *descriptorpb.EnumValueDescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_EnumValueOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if m.Number != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x10
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_ServiceDescriptorProto(m *descriptorpb.ServiceDescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_ServiceDescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_ServiceDescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_ServiceDescriptorProto(m *descriptorpb.ServiceDescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_ServiceDescriptorProto(m)
	return MarshalToSizedBufferVT_ServiceDescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_ServiceDescriptorProto(m *descriptorpb.ServiceDescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_ServiceOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Method) > 0 {
		for iNdEx := len(m.Method) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_MethodDescriptorProto(m.Method[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_MethodDescriptorProto(m *descriptorpb.MethodDescriptorProto) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_MethodDescriptorProto(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_MethodDescriptorProto(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_MethodDescriptorProto(m *descriptorpb.MethodDescriptorProto, dAtA []byte) (int, error) {
	size := SizeVT_MethodDescriptorProto(m)
	return MarshalToSizedBufferVT_MethodDescriptorProto(m, dAtA[:size])
}

func MarshalToSizedBufferVT_MethodDescriptorProto(m *descriptorpb.MethodDescriptorProto, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.ServerStreaming != nil {
		i--
		if *m.ServerStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ClientStreaming != nil {
		i--
		if *m.ClientStreaming {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Options != nil {
		size, err := MarshalToSizedBufferVT_MethodOptions(m.Options, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x22
	}
	if m.OutputType != nil {
		i -= len(*m.OutputType)
		copy(dAtA[i:], *m.OutputType)
		i = encodeVarint(dAtA, i, uint64(len(*m.OutputType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.InputType != nil {
		i -= len(*m.InputType)
		copy(dAtA[i:], *m.InputType)
		i = encodeVarint(dAtA, i, uint64(len(*m.InputType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Name != nil {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarint(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_FileOptions(m *descriptorpb.FileOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_FileOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_FileOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_FileOptions(m *descriptorpb.FileOptions, dAtA []byte) (int, error) {
	size := SizeVT_FileOptions(m)
	return MarshalToSizedBufferVT_FileOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_FileOptions(m *descriptorpb.FileOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.RubyPackage != nil {
		i -= len(*m.RubyPackage)
		copy(dAtA[i:], *m.RubyPackage)
		i = encodeVarint(dAtA, i, uint64(len(*m.RubyPackage)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	if m.PhpMetadataNamespace != nil {
		i -= len(*m.PhpMetadataNamespace)
		copy(dAtA[i:], *m.PhpMetadataNamespace)
		i = encodeVarint(dAtA, i, uint64(len(*m.PhpMetadataNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.PhpGenericServices != nil {
		i--
		if *m.PhpGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.PhpNamespace != nil {
		i -= len(*m.PhpNamespace)
		copy(dAtA[i:], *m.PhpNamespace)
		i = encodeVarint(dAtA, i, uint64(len(*m.PhpNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.PhpClassPrefix != nil {
		i -= len(*m.PhpClassPrefix)
		copy(dAtA[i:], *m.PhpClassPrefix)
		i = encodeVarint(dAtA, i, uint64(len(*m.PhpClassPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.SwiftPrefix != nil {
		i -= len(*m.SwiftPrefix)
		copy(dAtA[i:], *m.SwiftPrefix)
		i = encodeVarint(dAtA, i, uint64(len(*m.SwiftPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xba
	}
	if m.CsharpNamespace != nil {
		i -= len(*m.CsharpNamespace)
		copy(dAtA[i:], *m.CsharpNamespace)
		i = encodeVarint(dAtA, i, uint64(len(*m.CsharpNamespace)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.ObjcClassPrefix != nil {
		i -= len(*m.ObjcClassPrefix)
		copy(dAtA[i:], *m.ObjcClassPrefix)
		i = encodeVarint(dAtA, i, uint64(len(*m.ObjcClassPrefix)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa2
	}
	if m.CcEnableArenas != nil {
		i--
		if *m.CcEnableArenas {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.JavaStringCheckUtf8 != nil {
		i--
		if *m.JavaStringCheckUtf8 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.JavaGenerateEqualsAndHash != nil {
		i--
		if *m.JavaGenerateEqualsAndHash {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.PyGenericServices != nil {
		i--
		if *m.PyGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.JavaGenericServices != nil {
		i--
		if *m.JavaGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.CcGenericServices != nil {
		i--
		if *m.CcGenericServices {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.GoPackage != nil {
		i -= len(*m.GoPackage)
		copy(dAtA[i:], *m.GoPackage)
		i = encodeVarint(dAtA, i, uint64(len(*m.GoPackage)))
		i--
		dAtA[i] = 0x5a
	}
	if m.JavaMultipleFiles != nil {
		i--
		if *m.JavaMultipleFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.OptimizeFor != nil {
		i = encodeVarint(dAtA, i, uint64(*m.OptimizeFor))
		i--
		dAtA[i] = 0x48
	}
	if m.JavaOuterClassname != nil {
		i -= len(*m.JavaOuterClassname)
		copy(dAtA[i:], *m.JavaOuterClassname)
		i = encodeVarint(dAtA, i, uint64(len(*m.JavaOuterClassname)))
		i--
		dAtA[i] = 0x42
	}
	if m.JavaPackage != nil {
		i -= len(*m.JavaPackage)
		copy(dAtA[i:], *m.JavaPackage)
		i = encodeVarint(dAtA, i, uint64(len(*m.JavaPackage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_MessageOptions(m *descriptorpb.MessageOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_MessageOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_MessageOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_MessageOptions(m *descriptorpb.MessageOptions, dAtA []byte) (int, error) {
	size := SizeVT_MessageOptions(m)
	return MarshalToSizedBufferVT_MessageOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_MessageOptions(m *descriptorpb.MessageOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.MapEntry != nil {
		i--
		if *m.MapEntry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.NoStandardDescriptorAccessor != nil {
		i--
		if *m.NoStandardDescriptorAccessor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MessageSetWireFormat != nil {
		i--
		if *m.MessageSetWireFormat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func MarshalVT_FieldOptions(m *descriptorpb.FieldOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_FieldOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_FieldOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_FieldOptions(m *descriptorpb.FieldOptions, dAtA []byte) (int, error) {
	size := SizeVT_FieldOptions(m)
	return MarshalToSizedBufferVT_FieldOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_FieldOptions(m *descriptorpb.FieldOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Weak != nil {
		i--
		if *m.Weak {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Jstype != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Jstype))
		i--
		dAtA[i] = 0x30
	}
	if m.Lazy != nil {
		i--
		if *m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Packed != nil {
		i--
		if *m.Packed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Ctype != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Ctype))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func MarshalVT_OneofOptions(m *descriptorpb.OneofOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_OneofOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_OneofOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_OneofOptions(m *descriptorpb.OneofOptions, dAtA []byte) (int, error) {
	size := SizeVT_OneofOptions(m)
	return MarshalToSizedBufferVT_OneofOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_OneofOptions(m *descriptorpb.OneofOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	return len(dAtA) - i, nil
}

func MarshalVT_EnumOptions(m *descriptorpb.EnumOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_EnumOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_EnumOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_EnumOptions(m *descriptorpb.EnumOptions, dAtA []byte) (int, error) {
	size := SizeVT_EnumOptions(m)
	return MarshalToSizedBufferVT_EnumOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_EnumOptions(m *descriptorpb.EnumOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AllowAlias != nil {
		i--
		if *m.AllowAlias {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func MarshalVT_EnumValueOptions(m *descriptorpb.EnumValueOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_EnumValueOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_EnumValueOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_EnumValueOptions(m *descriptorpb.EnumValueOptions, dAtA []byte) (int, error) {
	size := SizeVT_EnumValueOptions(m)
	return MarshalToSizedBufferVT_EnumValueOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_EnumValueOptions(m *descriptorpb.EnumValueOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func MarshalVT_ServiceOptions(m *descriptorpb.ServiceOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_ServiceOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_ServiceOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_ServiceOptions(m *descriptorpb.ServiceOptions, dAtA []byte) (int, error) {
	size := SizeVT_ServiceOptions(m)
	return MarshalToSizedBufferVT_ServiceOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_ServiceOptions(m *descriptorpb.ServiceOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	return len(dAtA) - i, nil
}

func MarshalVT_MethodOptions(m *descriptorpb.MethodOptions) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_MethodOptions(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_MethodOptions(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_MethodOptions(m *descriptorpb.MethodOptions, dAtA []byte) (int, error) {
	size := SizeVT_MethodOptions(m)
	return MarshalToSizedBufferVT_MethodOptions(m, dAtA[:size])
}

func MarshalToSizedBufferVT_MethodOptions(m *descriptorpb.MethodOptions, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.UninterpretedOption) > 0 {
		for iNdEx := len(m.UninterpretedOption) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption(m.UninterpretedOption[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x3e
			i--
			dAtA[i] = 0xba
		}
	}
	if m.IdempotencyLevel != nil {
		i = encodeVarint(dAtA, i, uint64(*m.IdempotencyLevel))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.Deprecated != nil {
		i--
		if *m.Deprecated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	return len(dAtA) - i, nil
}

func MarshalVT_UninterpretedOption_NamePart(m *descriptorpb.UninterpretedOption_NamePart) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_UninterpretedOption_NamePart(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_UninterpretedOption_NamePart(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_UninterpretedOption_NamePart(m *descriptorpb.UninterpretedOption_NamePart, dAtA []byte) (int, error) {
	size := SizeVT_UninterpretedOption_NamePart(m)
	return MarshalToSizedBufferVT_UninterpretedOption_NamePart(m, dAtA[:size])
}

func MarshalToSizedBufferVT_UninterpretedOption_NamePart(m *descriptorpb.UninterpretedOption_NamePart, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.IsExtension == nil {
		return 0, fmt.Errorf("proto: required field is_extension not set")
	} else {
		i--
		if *m.IsExtension {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.NamePart == nil {
		return 0, fmt.Errorf("proto: required field name_part not set")
	} else {
		i -= len(*m.NamePart)
		copy(dAtA[i:], *m.NamePart)
		i = encodeVarint(dAtA, i, uint64(len(*m.NamePart)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_UninterpretedOption(m *descriptorpb.UninterpretedOption) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_UninterpretedOption(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_UninterpretedOption(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_UninterpretedOption(m *descriptorpb.UninterpretedOption, dAtA []byte) (int, error) {
	size := SizeVT_UninterpretedOption(m)
	return MarshalToSizedBufferVT_UninterpretedOption(m, dAtA[:size])
}

func MarshalToSizedBufferVT_UninterpretedOption(m *descriptorpb.UninterpretedOption, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.AggregateValue != nil {
		i -= len(*m.AggregateValue)
		copy(dAtA[i:], *m.AggregateValue)
		i = encodeVarint(dAtA, i, uint64(len(*m.AggregateValue)))
		i--
		dAtA[i] = 0x42
	}
	if m.StringValue != nil {
		i -= len(m.StringValue)
		copy(dAtA[i:], m.StringValue)
		i = encodeVarint(dAtA, i, uint64(len(m.StringValue)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DoubleValue != nil {
		i -= 8
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i--
		dAtA[i] = 0x31
	}
	if m.NegativeIntValue != nil {
		i = encodeVarint(dAtA, i, uint64(*m.NegativeIntValue))
		i--
		dAtA[i] = 0x28
	}
	if m.PositiveIntValue != nil {
		i = encodeVarint(dAtA, i, uint64(*m.PositiveIntValue))
		i--
		dAtA[i] = 0x20
	}
	if m.IdentifierValue != nil {
		i -= len(*m.IdentifierValue)
		copy(dAtA[i:], *m.IdentifierValue)
		i = encodeVarint(dAtA, i, uint64(len(*m.IdentifierValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		for iNdEx := len(m.Name) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_UninterpretedOption_NamePart(m.Name[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func MarshalVT_SourceCodeInfo_Location(m *descriptorpb.SourceCodeInfo_Location) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_SourceCodeInfo_Location(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_SourceCodeInfo_Location(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_SourceCodeInfo_Location(m *descriptorpb.SourceCodeInfo_Location, dAtA []byte) (int, error) {
	size := SizeVT_SourceCodeInfo_Location(m)
	return MarshalToSizedBufferVT_SourceCodeInfo_Location(m, dAtA[:size])
}

func MarshalToSizedBufferVT_SourceCodeInfo_Location(m *descriptorpb.SourceCodeInfo_Location, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.LeadingDetachedComments) > 0 {
		for iNdEx := len(m.LeadingDetachedComments) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LeadingDetachedComments[iNdEx])
			copy(dAtA[i:], m.LeadingDetachedComments[iNdEx])
			i = encodeVarint(dAtA, i, uint64(len(m.LeadingDetachedComments[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.TrailingComments != nil {
		i -= len(*m.TrailingComments)
		copy(dAtA[i:], *m.TrailingComments)
		i = encodeVarint(dAtA, i, uint64(len(*m.TrailingComments)))
		i--
		dAtA[i] = 0x22
	}
	if m.LeadingComments != nil {
		i -= len(*m.LeadingComments)
		copy(dAtA[i:], *m.LeadingComments)
		i = encodeVarint(dAtA, i, uint64(len(*m.LeadingComments)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Span) > 0 {
		var pksize2 int
		for _, num := range m.Span {
			pksize2 += sov(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.Span {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = encodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		var pksize4 int
		for _, num := range m.Path {
			pksize4 += sov(uint64(num))
		}
		i -= pksize4
		j3 := i
		for _, num1 := range m.Path {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA[j3] = uint8(num)
			j3++
		}
		i = encodeVarint(dAtA, i, uint64(pksize4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_SourceCodeInfo(m *descriptorpb.SourceCodeInfo) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_SourceCodeInfo(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_SourceCodeInfo(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_SourceCodeInfo(m *descriptorpb.SourceCodeInfo, dAtA []byte) (int, error) {
	size := SizeVT_SourceCodeInfo(m)
	return MarshalToSizedBufferVT_SourceCodeInfo(m, dAtA[:size])
}

func MarshalToSizedBufferVT_SourceCodeInfo(m *descriptorpb.SourceCodeInfo, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.Location) > 0 {
		for iNdEx := len(m.Location) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_SourceCodeInfo_Location(m.Location[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func MarshalVT_GeneratedCodeInfo_Annotation(m *descriptorpb.GeneratedCodeInfo_Annotation) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_GeneratedCodeInfo_Annotation(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_GeneratedCodeInfo_Annotation(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_GeneratedCodeInfo_Annotation(m *descriptorpb.GeneratedCodeInfo_Annotation, dAtA []byte) (int, error) {
	size := SizeVT_GeneratedCodeInfo_Annotation(m)
	return MarshalToSizedBufferVT_GeneratedCodeInfo_Annotation(m, dAtA[:size])
}

func MarshalToSizedBufferVT_GeneratedCodeInfo_Annotation(m *descriptorpb.GeneratedCodeInfo_Annotation, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.End != nil {
		i = encodeVarint(dAtA, i, uint64(*m.End))
		i--
		dAtA[i] = 0x20
	}
	if m.Begin != nil {
		i = encodeVarint(dAtA, i, uint64(*m.Begin))
		i--
		dAtA[i] = 0x18
	}
	if m.SourceFile != nil {
		i -= len(*m.SourceFile)
		copy(dAtA[i:], *m.SourceFile)
		i = encodeVarint(dAtA, i, uint64(len(*m.SourceFile)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		var pksize2 int
		for _, num := range m.Path {
			pksize2 += sov(uint64(num))
		}
		i -= pksize2
		j1 := i
		for _, num1 := range m.Path {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA[j1] = uint8(num)
			j1++
		}
		i = encodeVarint(dAtA, i, uint64(pksize2))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func MarshalVT_GeneratedCodeInfo(m *descriptorpb.GeneratedCodeInfo) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_GeneratedCodeInfo(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_GeneratedCodeInfo(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_GeneratedCodeInfo(m *descriptorpb.GeneratedCodeInfo, dAtA []byte) (int, error) {
	size := SizeVT_GeneratedCodeInfo(m)
	return MarshalToSizedBufferVT_GeneratedCodeInfo(m, dAtA[:size])
}

func MarshalToSizedBufferVT_GeneratedCodeInfo(m *descriptorpb.GeneratedCodeInfo, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.Annotation) > 0 {
		for iNdEx := len(m.Annotation) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_GeneratedCodeInfo_Annotation(m.Annotation[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarint(dAtA []byte, offset int, v uint64) int {
	offset -= sov(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func SizeVT_FileDescriptorSet(m *descriptorpb.FileDescriptorSet) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.File) > 0 {
		for _, e := range m.File {
			l = SizeVT_FileDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_FileDescriptorProto(m *descriptorpb.FileDescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if m.Package != nil {
		l = len(*m.Package)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Dependency) > 0 {
		for _, s := range m.Dependency {
			l = len(s)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.MessageType) > 0 {
		for _, e := range m.MessageType {
			l = SizeVT_DescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.EnumType) > 0 {
		for _, e := range m.EnumType {
			l = SizeVT_EnumDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Service) > 0 {
		for _, e := range m.Service {
			l = SizeVT_ServiceDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = SizeVT_FieldDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.Options != nil {
		l = SizeVT_FileOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	if m.SourceCodeInfo != nil {
		l = SizeVT_SourceCodeInfo(m.SourceCodeInfo)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.PublicDependency) > 0 {
		for _, e := range m.PublicDependency {
			n += 1 + sov(uint64(e))
		}
	}
	if len(m.WeakDependency) > 0 {
		for _, e := range m.WeakDependency {
			n += 1 + sov(uint64(e))
		}
	}
	if m.Syntax != nil {
		l = len(*m.Syntax)
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_DescriptorProto_ExtensionRange(m *descriptorpb.DescriptorProto_ExtensionRange) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		n += 1 + sov(uint64(*m.Start))
	}
	if m.End != nil {
		n += 1 + sov(uint64(*m.End))
	}
	if m.Options != nil {
		l = SizeVT_ExtensionRangeOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_DescriptorProto_ReservedRange(m *descriptorpb.DescriptorProto_ReservedRange) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		n += 1 + sov(uint64(*m.Start))
	}
	if m.End != nil {
		n += 1 + sov(uint64(*m.End))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_DescriptorProto(m *descriptorpb.DescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Field) > 0 {
		for _, e := range m.Field {
			l = SizeVT_FieldDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.NestedType) > 0 {
		for _, e := range m.NestedType {
			l = SizeVT_DescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.EnumType) > 0 {
		for _, e := range m.EnumType {
			l = SizeVT_EnumDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.ExtensionRange) > 0 {
		for _, e := range m.ExtensionRange {
			l = SizeVT_DescriptorProto_ExtensionRange(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.Extension) > 0 {
		for _, e := range m.Extension {
			l = SizeVT_FieldDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.Options != nil {
		l = SizeVT_MessageOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.OneofDecl) > 0 {
		for _, e := range m.OneofDecl {
			l = SizeVT_OneofDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.ReservedRange) > 0 {
		for _, e := range m.ReservedRange {
			l = SizeVT_DescriptorProto_ReservedRange(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.ReservedName) > 0 {
		for _, s := range m.ReservedName {
			l = len(s)
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_ExtensionRangeOptions(m *descriptorpb.ExtensionRangeOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_FieldDescriptorProto(m *descriptorpb.FieldDescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if m.Extendee != nil {
		l = len(*m.Extendee)
		n += 1 + l + sov(uint64(l))
	}
	if m.Number != nil {
		n += 1 + sov(uint64(*m.Number))
	}
	if m.Label != nil {
		n += 1 + sov(uint64(*m.Label))
	}
	if m.Type != nil {
		n += 1 + sov(uint64(*m.Type))
	}
	if m.TypeName != nil {
		l = len(*m.TypeName)
		n += 1 + l + sov(uint64(l))
	}
	if m.DefaultValue != nil {
		l = len(*m.DefaultValue)
		n += 1 + l + sov(uint64(l))
	}
	if m.Options != nil {
		l = SizeVT_FieldOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	if m.OneofIndex != nil {
		n += 1 + sov(uint64(*m.OneofIndex))
	}
	if m.JsonName != nil {
		l = len(*m.JsonName)
		n += 1 + l + sov(uint64(l))
	}
	if m.Proto3Optional != nil {
		n += 3
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_OneofDescriptorProto(m *descriptorpb.OneofDescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if m.Options != nil {
		l = SizeVT_OneofOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_EnumDescriptorProto_EnumReservedRange(m *descriptorpb.EnumDescriptorProto_EnumReservedRange) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		n += 1 + sov(uint64(*m.Start))
	}
	if m.End != nil {
		n += 1 + sov(uint64(*m.End))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_EnumDescriptorProto(m *descriptorpb.EnumDescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Value) > 0 {
		for _, e := range m.Value {
			l = SizeVT_EnumValueDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.Options != nil {
		l = SizeVT_EnumOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.ReservedRange) > 0 {
		for _, e := range m.ReservedRange {
			l = SizeVT_EnumDescriptorProto_EnumReservedRange(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if len(m.ReservedName) > 0 {
		for _, s := range m.ReservedName {
			l = len(s)
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_EnumValueDescriptorProto(m *descriptorpb.EnumValueDescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if m.Number != nil {
		n += 1 + sov(uint64(*m.Number))
	}
	if m.Options != nil {
		l = SizeVT_EnumValueOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_ServiceDescriptorProto(m *descriptorpb.ServiceDescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.Method) > 0 {
		for _, e := range m.Method {
			l = SizeVT_MethodDescriptorProto(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.Options != nil {
		l = SizeVT_ServiceOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_MethodDescriptorProto(m *descriptorpb.MethodDescriptorProto) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sov(uint64(l))
	}
	if m.InputType != nil {
		l = len(*m.InputType)
		n += 1 + l + sov(uint64(l))
	}
	if m.OutputType != nil {
		l = len(*m.OutputType)
		n += 1 + l + sov(uint64(l))
	}
	if m.Options != nil {
		l = SizeVT_MethodOptions(m.Options)
		n += 1 + l + sov(uint64(l))
	}
	if m.ClientStreaming != nil {
		n += 2
	}
	if m.ServerStreaming != nil {
		n += 2
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_FileOptions(m *descriptorpb.FileOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavaPackage != nil {
		l = len(*m.JavaPackage)
		n += 1 + l + sov(uint64(l))
	}
	if m.JavaOuterClassname != nil {
		l = len(*m.JavaOuterClassname)
		n += 1 + l + sov(uint64(l))
	}
	if m.OptimizeFor != nil {
		n += 1 + sov(uint64(*m.OptimizeFor))
	}
	if m.JavaMultipleFiles != nil {
		n += 2
	}
	if m.GoPackage != nil {
		l = len(*m.GoPackage)
		n += 1 + l + sov(uint64(l))
	}
	if m.CcGenericServices != nil {
		n += 3
	}
	if m.JavaGenericServices != nil {
		n += 3
	}
	if m.PyGenericServices != nil {
		n += 3
	}
	if m.JavaGenerateEqualsAndHash != nil {
		n += 3
	}
	if m.Deprecated != nil {
		n += 3
	}
	if m.JavaStringCheckUtf8 != nil {
		n += 3
	}
	if m.CcEnableArenas != nil {
		n += 3
	}
	if m.ObjcClassPrefix != nil {
		l = len(*m.ObjcClassPrefix)
		n += 2 + l + sov(uint64(l))
	}
	if m.CsharpNamespace != nil {
		l = len(*m.CsharpNamespace)
		n += 2 + l + sov(uint64(l))
	}
	if m.SwiftPrefix != nil {
		l = len(*m.SwiftPrefix)
		n += 2 + l + sov(uint64(l))
	}
	if m.PhpClassPrefix != nil {
		l = len(*m.PhpClassPrefix)
		n += 2 + l + sov(uint64(l))
	}
	if m.PhpNamespace != nil {
		l = len(*m.PhpNamespace)
		n += 2 + l + sov(uint64(l))
	}
	if m.PhpGenericServices != nil {
		n += 3
	}
	if m.PhpMetadataNamespace != nil {
		l = len(*m.PhpMetadataNamespace)
		n += 2 + l + sov(uint64(l))
	}
	if m.RubyPackage != nil {
		l = len(*m.RubyPackage)
		n += 2 + l + sov(uint64(l))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_MessageOptions(m *descriptorpb.MessageOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageSetWireFormat != nil {
		n += 2
	}
	if m.NoStandardDescriptorAccessor != nil {
		n += 2
	}
	if m.Deprecated != nil {
		n += 2
	}
	if m.MapEntry != nil {
		n += 2
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_FieldOptions(m *descriptorpb.FieldOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ctype != nil {
		n += 1 + sov(uint64(*m.Ctype))
	}
	if m.Packed != nil {
		n += 2
	}
	if m.Deprecated != nil {
		n += 2
	}
	if m.Lazy != nil {
		n += 2
	}
	if m.Jstype != nil {
		n += 1 + sov(uint64(*m.Jstype))
	}
	if m.Weak != nil {
		n += 2
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_OneofOptions(m *descriptorpb.OneofOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_EnumOptions(m *descriptorpb.EnumOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AllowAlias != nil {
		n += 2
	}
	if m.Deprecated != nil {
		n += 2
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_EnumValueOptions(m *descriptorpb.EnumValueOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deprecated != nil {
		n += 2
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_ServiceOptions(m *descriptorpb.ServiceOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deprecated != nil {
		n += 3
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_MethodOptions(m *descriptorpb.MethodOptions) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Deprecated != nil {
		n += 3
	}
	if m.IdempotencyLevel != nil {
		n += 2 + sov(uint64(*m.IdempotencyLevel))
	}
	if len(m.UninterpretedOption) > 0 {
		for _, e := range m.UninterpretedOption {
			l = SizeVT_UninterpretedOption(e)
			n += 2 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_UninterpretedOption_NamePart(m *descriptorpb.UninterpretedOption_NamePart) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NamePart != nil {
		l = len(*m.NamePart)
		n += 1 + l + sov(uint64(l))
	}
	if m.IsExtension != nil {
		n += 2
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_UninterpretedOption(m *descriptorpb.UninterpretedOption) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Name) > 0 {
		for _, e := range m.Name {
			l = SizeVT_UninterpretedOption_NamePart(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	if m.IdentifierValue != nil {
		l = len(*m.IdentifierValue)
		n += 1 + l + sov(uint64(l))
	}
	if m.PositiveIntValue != nil {
		n += 1 + sov(uint64(*m.PositiveIntValue))
	}
	if m.NegativeIntValue != nil {
		n += 1 + sov(uint64(*m.NegativeIntValue))
	}
	if m.DoubleValue != nil {
		n += 9
	}
	if m.StringValue != nil {
		l = len(m.StringValue)
		n += 1 + l + sov(uint64(l))
	}
	if m.AggregateValue != nil {
		l = len(*m.AggregateValue)
		n += 1 + l + sov(uint64(l))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_SourceCodeInfo_Location(m *descriptorpb.SourceCodeInfo_Location) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Path) > 0 {
		l = 0
		for _, e := range m.Path {
			l += sov(uint64(e))
		}
		n += 1 + sov(uint64(l)) + l
	}
	if len(m.Span) > 0 {
		l = 0
		for _, e := range m.Span {
			l += sov(uint64(e))
		}
		n += 1 + sov(uint64(l)) + l
	}
	if m.LeadingComments != nil {
		l = len(*m.LeadingComments)
		n += 1 + l + sov(uint64(l))
	}
	if m.TrailingComments != nil {
		l = len(*m.TrailingComments)
		n += 1 + l + sov(uint64(l))
	}
	if len(m.LeadingDetachedComments) > 0 {
		for _, s := range m.LeadingDetachedComments {
			l = len(s)
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_SourceCodeInfo(m *descriptorpb.SourceCodeInfo) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Location) > 0 {
		for _, e := range m.Location {
			l = SizeVT_SourceCodeInfo_Location(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_GeneratedCodeInfo_Annotation(m *descriptorpb.GeneratedCodeInfo_Annotation) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Path) > 0 {
		l = 0
		for _, e := range m.Path {
			l += sov(uint64(e))
		}
		n += 1 + sov(uint64(l)) + l
	}
	if m.SourceFile != nil {
		l = len(*m.SourceFile)
		n += 1 + l + sov(uint64(l))
	}
	if m.Begin != nil {
		n += 1 + sov(uint64(*m.Begin))
	}
	if m.End != nil {
		n += 1 + sov(uint64(*m.End))
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_GeneratedCodeInfo(m *descriptorpb.GeneratedCodeInfo) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Annotation) > 0 {
		for _, e := range m.Annotation {
			l = SizeVT_GeneratedCodeInfo_Annotation(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func sov(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func soz(x uint64) (n int) {
	return sov(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func UnmarshalVT_FileDescriptorSet(m *descriptorpb.FileDescriptorSet, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDescriptorSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDescriptorSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File, &descriptorpb.FileDescriptorProto{})
			if err := UnmarshalVT_FileDescriptorProto(m.File[len(m.File)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_FileDescriptorProto(m *descriptorpb.FileDescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Package = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependency = append(m.Dependency, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageType = append(m.MessageType, &descriptorpb.DescriptorProto{})
			if err := UnmarshalVT_DescriptorProto(m.MessageType[len(m.MessageType)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumType = append(m.EnumType, &descriptorpb.EnumDescriptorProto{})
			if err := UnmarshalVT_EnumDescriptorProto(m.EnumType[len(m.EnumType)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = append(m.Service, &descriptorpb.ServiceDescriptorProto{})
			if err := UnmarshalVT_ServiceDescriptorProto(m.Service[len(m.Service)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &descriptorpb.FieldDescriptorProto{})
			if err := UnmarshalVT_FieldDescriptorProto(m.Extension[len(m.Extension)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.FileOptions{}
			}
			if err := UnmarshalVT_FileOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCodeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceCodeInfo == nil {
				m.SourceCodeInfo = &descriptorpb.SourceCodeInfo{}
			}
			if err := UnmarshalVT_SourceCodeInfo(m.SourceCodeInfo, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PublicDependency = append(m.PublicDependency, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PublicDependency) == 0 {
					m.PublicDependency = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PublicDependency = append(m.PublicDependency, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicDependency", wireType)
			}
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.WeakDependency = append(m.WeakDependency, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.WeakDependency) == 0 {
					m.WeakDependency = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.WeakDependency = append(m.WeakDependency, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field WeakDependency", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Syntax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Syntax = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_DescriptorProto_ExtensionRange(m *descriptorpb.DescriptorProto_ExtensionRange, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorProto_ExtensionRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorProto_ExtensionRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.ExtensionRangeOptions{}
			}
			if err := UnmarshalVT_ExtensionRangeOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_DescriptorProto_ReservedRange(m *descriptorpb.DescriptorProto_ReservedRange, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorProto_ReservedRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorProto_ReservedRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_DescriptorProto(m *descriptorpb.DescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Field = append(m.Field, &descriptorpb.FieldDescriptorProto{})
			if err := UnmarshalVT_FieldDescriptorProto(m.Field[len(m.Field)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NestedType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NestedType = append(m.NestedType, &descriptorpb.DescriptorProto{})
			if err := UnmarshalVT_DescriptorProto(m.NestedType[len(m.NestedType)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumType = append(m.EnumType, &descriptorpb.EnumDescriptorProto{})
			if err := UnmarshalVT_EnumDescriptorProto(m.EnumType[len(m.EnumType)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtensionRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtensionRange = append(m.ExtensionRange, &descriptorpb.DescriptorProto_ExtensionRange{})
			if err := UnmarshalVT_DescriptorProto_ExtensionRange(m.ExtensionRange[len(m.ExtensionRange)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension, &descriptorpb.FieldDescriptorProto{})
			if err := UnmarshalVT_FieldDescriptorProto(m.Extension[len(m.Extension)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.MessageOptions{}
			}
			if err := UnmarshalVT_MessageOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofDecl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneofDecl = append(m.OneofDecl, &descriptorpb.OneofDescriptorProto{})
			if err := UnmarshalVT_OneofDescriptorProto(m.OneofDecl[len(m.OneofDecl)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedRange = append(m.ReservedRange, &descriptorpb.DescriptorProto_ReservedRange{})
			if err := UnmarshalVT_DescriptorProto_ReservedRange(m.ReservedRange[len(m.ReservedRange)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedName = append(m.ReservedName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_ExtensionRangeOptions(m *descriptorpb.ExtensionRangeOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtensionRangeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtensionRangeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_FieldDescriptorProto(m *descriptorpb.FieldDescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extendee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Extendee = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var v descriptorpb.FieldDescriptorProto_Label
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= descriptorpb.FieldDescriptorProto_Label(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Label = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v descriptorpb.FieldDescriptorProto_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= descriptorpb.FieldDescriptorProto_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TypeName = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DefaultValue = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.FieldOptions{}
			}
			if err := UnmarshalVT_FieldOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneofIndex", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OneofIndex = &v
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JsonName = &s
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proto3Optional", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Proto3Optional = &b
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_OneofDescriptorProto(m *descriptorpb.OneofDescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneofDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneofDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.OneofOptions{}
			}
			if err := UnmarshalVT_OneofOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_EnumDescriptorProto_EnumReservedRange(m *descriptorpb.EnumDescriptorProto_EnumReservedRange, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumDescriptorProto_EnumReservedRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumDescriptorProto_EnumReservedRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Start = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_EnumDescriptorProto(m *descriptorpb.EnumDescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value, &descriptorpb.EnumValueDescriptorProto{})
			if err := UnmarshalVT_EnumValueDescriptorProto(m.Value[len(m.Value)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.EnumOptions{}
			}
			if err := UnmarshalVT_EnumOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedRange = append(m.ReservedRange, &descriptorpb.EnumDescriptorProto_EnumReservedRange{})
			if err := UnmarshalVT_EnumDescriptorProto_EnumReservedRange(m.ReservedRange[len(m.ReservedRange)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservedName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReservedName = append(m.ReservedName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_EnumValueDescriptorProto(m *descriptorpb.EnumValueDescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumValueDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumValueDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.EnumValueOptions{}
			}
			if err := UnmarshalVT_EnumValueOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_ServiceDescriptorProto(m *descriptorpb.ServiceDescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = append(m.Method, &descriptorpb.MethodDescriptorProto{})
			if err := UnmarshalVT_MethodDescriptorProto(m.Method[len(m.Method)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.ServiceOptions{}
			}
			if err := UnmarshalVT_ServiceOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_MethodDescriptorProto(m *descriptorpb.MethodDescriptorProto, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MethodDescriptorProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MethodDescriptorProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.InputType = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.OutputType = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &descriptorpb.MethodOptions{}
			}
			if err := UnmarshalVT_MethodOptions(m.Options, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ClientStreaming = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStreaming", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ServerStreaming = &b
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_FileOptions(m *descriptorpb.FileOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JavaPackage = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaOuterClassname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.JavaOuterClassname = &s
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptimizeFor", wireType)
			}
			var v descriptorpb.FileOptions_OptimizeMode
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= descriptorpb.FileOptions_OptimizeMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OptimizeFor = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaMultipleFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaMultipleFiles = &b
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.GoPackage = &s
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CcGenericServices = &b
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaGenericServices = &b
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PyGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PyGenericServices = &b
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaGenerateEqualsAndHash", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaGenerateEqualsAndHash = &b
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaStringCheckUtf8", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.JavaStringCheckUtf8 = &b
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CcEnableArenas", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.CcEnableArenas = &b
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjcClassPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ObjcClassPrefix = &s
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CsharpNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CsharpNamespace = &s
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwiftPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SwiftPrefix = &s
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhpClassPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhpClassPrefix = &s
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhpNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhpNamespace = &s
			iNdEx = postIndex
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhpGenericServices", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.PhpGenericServices = &b
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhpMetadataNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PhpMetadataNamespace = &s
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RubyPackage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RubyPackage = &s
			iNdEx = postIndex
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_MessageOptions(m *descriptorpb.MessageOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageSetWireFormat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MessageSetWireFormat = &b
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoStandardDescriptorAccessor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NoStandardDescriptorAccessor = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapEntry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MapEntry = &b
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_FieldOptions(m *descriptorpb.FieldOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctype", wireType)
			}
			var v descriptorpb.FieldOptions_CType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= descriptorpb.FieldOptions_CType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ctype = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Packed = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Lazy = &b
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jstype", wireType)
			}
			var v descriptorpb.FieldOptions_JSType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= descriptorpb.FieldOptions_JSType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jstype = &v
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weak", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Weak = &b
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_OneofOptions(m *descriptorpb.OneofOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneofOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneofOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_EnumOptions(m *descriptorpb.EnumOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowAlias", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.AllowAlias = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_EnumValueOptions(m *descriptorpb.EnumValueOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnumValueOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnumValueOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_ServiceOptions(m *descriptorpb.ServiceOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_MethodOptions(m *descriptorpb.MethodOptions, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MethodOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MethodOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Deprecated = &b
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdempotencyLevel", wireType)
			}
			var v descriptorpb.MethodOptions_IdempotencyLevel
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= descriptorpb.MethodOptions_IdempotencyLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IdempotencyLevel = &v
		case 999:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UninterpretedOption", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UninterpretedOption = append(m.UninterpretedOption, &descriptorpb.UninterpretedOption{})
			if err := UnmarshalVT_UninterpretedOption(m.UninterpretedOption[len(m.UninterpretedOption)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			if (fieldNum >= 1000) && (fieldNum < 536870912) {
				err = proto.UnmarshalOptions{AllowPartial: true}.Unmarshal(dAtA[iNdEx:iNdEx+skippy], m)
				if err != nil {
					return err
				}
				iNdEx += skippy
			} else {
				unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
				iNdEx += skippy
			}
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_UninterpretedOption_NamePart(m *descriptorpb.UninterpretedOption_NamePart, dAtA []byte) error {
	var hasFields [1]uint64
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UninterpretedOption_NamePart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UninterpretedOption_NamePart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamePart", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.NamePart = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExtension", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsExtension = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return fmt.Errorf("proto: required field name_part not set")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return fmt.Errorf("proto: required field is_extension not set")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_UninterpretedOption(m *descriptorpb.UninterpretedOption, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UninterpretedOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UninterpretedOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, &descriptorpb.UninterpretedOption_NamePart{})
			if err := UnmarshalVT_UninterpretedOption_NamePart(m.Name[len(m.Name)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentifierValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IdentifierValue = &s
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PositiveIntValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PositiveIntValue = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NegativeIntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NegativeIntValue = &v
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StringValue = append(m.StringValue[:0], dAtA[iNdEx:postIndex]...)
			if m.StringValue == nil {
				m.StringValue = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregateValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AggregateValue = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_SourceCodeInfo_Location(m *descriptorpb.SourceCodeInfo_Location, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCodeInfo_Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCodeInfo_Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Path = append(m.Path, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Path) == 0 {
					m.Path = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Path = append(m.Path, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Span = append(m.Span, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Span) == 0 {
					m.Span = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Span = append(m.Span, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadingComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.LeadingComments = &s
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrailingComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TrailingComments = &s
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadingDetachedComments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeadingDetachedComments = append(m.LeadingDetachedComments, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_SourceCodeInfo(m *descriptorpb.SourceCodeInfo, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceCodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceCodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = append(m.Location, &descriptorpb.SourceCodeInfo_Location{})
			if err := UnmarshalVT_SourceCodeInfo_Location(m.Location[len(m.Location)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_GeneratedCodeInfo_Annotation(m *descriptorpb.GeneratedCodeInfo_Annotation, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedCodeInfo_Annotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedCodeInfo_Annotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Path = append(m.Path, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLength
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLength
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Path) == 0 {
					m.Path = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Path = append(m.Path, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SourceFile = &s
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Begin = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.End = &v
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_GeneratedCodeInfo(m *descriptorpb.GeneratedCodeInfo, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedCodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedCodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotation = append(m.Annotation, &descriptorpb.GeneratedCodeInfo_Annotation{})
			if err := UnmarshalVT_GeneratedCodeInfo_Annotation(m.Annotation[len(m.Annotation)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skip(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLength
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroup
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLength
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLength        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroup = fmt.Errorf("proto: unexpected end of group")
)

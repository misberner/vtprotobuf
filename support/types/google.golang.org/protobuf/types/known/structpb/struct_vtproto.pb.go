// Code generated by protoc-gen-go-vtproto. DO NOT EDIT.
// protoc-gen-go-vtproto version: (devel)
// source: google/protobuf/struct.proto

package structpb

import (
	binary "encoding/binary"
	fmt "fmt"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	structpb "google.golang.org/protobuf/types/known/structpb"
	io "io"
	math "math"
	bits "math/bits"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

func CloneVT_Struct(m *structpb.Struct) *structpb.Struct {
	if m == nil {
		return (*structpb.Struct)(nil)
	}
	r := &structpb.Struct{}
	if rhs := m.Fields; rhs != nil {
		tmpContainer := make(map[string]*structpb.Value, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_Value(v)
		}
		r.Fields = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_Value(m *structpb.Value) *structpb.Value {
	if m == nil {
		return (*structpb.Value)(nil)
	}
	r := &structpb.Value{}
	if m.Kind != nil {
		switch t := m.Kind.(type) {
		case *structpb.Value_NullValue:
			r.Kind = CloneVT_Value_NullValue(t)
		case *structpb.Value_NumberValue:
			r.Kind = CloneVT_Value_NumberValue(t)
		case *structpb.Value_StringValue:
			r.Kind = CloneVT_Value_StringValue(t)
		case *structpb.Value_BoolValue:
			r.Kind = CloneVT_Value_BoolValue(t)
		case *structpb.Value_StructValue:
			r.Kind = CloneVT_Value_StructValue(t)
		case *structpb.Value_ListValue:
			r.Kind = CloneVT_Value_ListValue(t)
		}
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func CloneVT_Value_NullValue(m *structpb.Value_NullValue) *structpb.Value_NullValue {
	if m == nil {
		return (*structpb.Value_NullValue)(nil)
	}
	r := &structpb.Value_NullValue{
		NullValue: m.NullValue,
	}
	return r
}

func CloneVT_Value_NumberValue(m *structpb.Value_NumberValue) *structpb.Value_NumberValue {
	if m == nil {
		return (*structpb.Value_NumberValue)(nil)
	}
	r := &structpb.Value_NumberValue{
		NumberValue: m.NumberValue,
	}
	return r
}

func CloneVT_Value_StringValue(m *structpb.Value_StringValue) *structpb.Value_StringValue {
	if m == nil {
		return (*structpb.Value_StringValue)(nil)
	}
	r := &structpb.Value_StringValue{
		StringValue: m.StringValue,
	}
	return r
}

func CloneVT_Value_BoolValue(m *structpb.Value_BoolValue) *structpb.Value_BoolValue {
	if m == nil {
		return (*structpb.Value_BoolValue)(nil)
	}
	r := &structpb.Value_BoolValue{
		BoolValue: m.BoolValue,
	}
	return r
}

func CloneVT_Value_StructValue(m *structpb.Value_StructValue) *structpb.Value_StructValue {
	if m == nil {
		return (*structpb.Value_StructValue)(nil)
	}
	r := &structpb.Value_StructValue{
		StructValue: CloneVT_Struct(m.StructValue),
	}
	return r
}

func CloneVT_Value_ListValue(m *structpb.Value_ListValue) *structpb.Value_ListValue {
	if m == nil {
		return (*structpb.Value_ListValue)(nil)
	}
	r := &structpb.Value_ListValue{
		ListValue: CloneVT_ListValue(m.ListValue),
	}
	return r
}

func CloneVT_ListValue(m *structpb.ListValue) *structpb.ListValue {
	if m == nil {
		return (*structpb.ListValue)(nil)
	}
	r := &structpb.ListValue{}
	if rhs := m.Values; rhs != nil {
		tmpContainer := make([]*structpb.Value, len(rhs))
		for k, v := range rhs {
			tmpContainer[k] = CloneVT_Value(v)
		}
		r.Values = tmpContainer
	}
	if uf := m.ProtoReflect().GetUnknown(); len(uf) > 0 {
		ufc := make([]byte, len(uf))
		copy(ufc, uf)
		r.ProtoReflect().SetUnknown(ufc)
	}
	return r
}

func EqualVT_Struct(this *structpb.Struct, that *structpb.Struct) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Fields) != len(that.Fields) {
		return false
	}
	for i, vx := range this.Fields {
		vy, ok := that.Fields[i]
		if !ok {
			return false
		}
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &structpb.Value{}
			}
			if q == nil {
				q = &structpb.Value{}
			}
			if !EqualVT_Value(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_Value(this *structpb.Value, that *structpb.Value) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if this.Kind == nil && that.Kind != nil {
		return false
	} else if this.Kind != nil {
		if that.Kind == nil {
			return false
		}
		switch f := this.Kind.(type) {
		case *structpb.Value_NullValue:
			if !EqualVT_Value_NullValue(f, that.Kind) {
				return false
			}
		case *structpb.Value_NumberValue:
			if !EqualVT_Value_NumberValue(f, that.Kind) {
				return false
			}
		case *structpb.Value_StringValue:
			if !EqualVT_Value_StringValue(f, that.Kind) {
				return false
			}
		case *structpb.Value_BoolValue:
			if !EqualVT_Value_BoolValue(f, that.Kind) {
				return false
			}
		case *structpb.Value_StructValue:
			if !EqualVT_Value_StructValue(f, that.Kind) {
				return false
			}
		case *structpb.Value_ListValue:
			if !EqualVT_Value_ListValue(f, that.Kind) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func EqualVT_Value_NullValue(this *structpb.Value_NullValue, thatIface interface{}) bool {
	that, ok := thatIface.(*structpb.Value_NullValue)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.NullValue != that.NullValue {
		return false
	}
	return true
}

func EqualVT_Value_NumberValue(this *structpb.Value_NumberValue, thatIface interface{}) bool {
	that, ok := thatIface.(*structpb.Value_NumberValue)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.NumberValue != that.NumberValue {
		return false
	}
	return true
}

func EqualVT_Value_StringValue(this *structpb.Value_StringValue, thatIface interface{}) bool {
	that, ok := thatIface.(*structpb.Value_StringValue)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.StringValue != that.StringValue {
		return false
	}
	return true
}

func EqualVT_Value_BoolValue(this *structpb.Value_BoolValue, thatIface interface{}) bool {
	that, ok := thatIface.(*structpb.Value_BoolValue)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if this.BoolValue != that.BoolValue {
		return false
	}
	return true
}

func EqualVT_Value_StructValue(this *structpb.Value_StructValue, thatIface interface{}) bool {
	that, ok := thatIface.(*structpb.Value_StructValue)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.StructValue, that.StructValue; p != q {
		if p == nil {
			p = &structpb.Struct{}
		}
		if q == nil {
			q = &structpb.Struct{}
		}
		if !EqualVT_Struct(p, q) {
			return false
		}
	}
	return true
}

func EqualVT_Value_ListValue(this *structpb.Value_ListValue, thatIface interface{}) bool {
	that, ok := thatIface.(*structpb.Value_ListValue)
	if !ok {
		return false
	}
	if this == that {
		return true
	}
	if this == nil && that != nil || this != nil && that == nil {
		return false
	}
	if p, q := this.ListValue, that.ListValue; p != q {
		if p == nil {
			p = &structpb.ListValue{}
		}
		if q == nil {
			q = &structpb.ListValue{}
		}
		if !EqualVT_ListValue(p, q) {
			return false
		}
	}
	return true
}

func EqualVT_ListValue(this *structpb.ListValue, that *structpb.ListValue) bool {
	if this == nil {
		return that == nil
	} else if that == nil {
		return false
	}
	if len(this.Values) != len(that.Values) {
		return false
	}
	for i, vx := range this.Values {
		vy := that.Values[i]
		if p, q := vx, vy; p != q {
			if p == nil {
				p = &structpb.Value{}
			}
			if q == nil {
				q = &structpb.Value{}
			}
			if !EqualVT_Value(p, q) {
				return false
			}
		}
	}
	return string(this.ProtoReflect().GetUnknown()) == string(that.ProtoReflect().GetUnknown())
}
func MarshalVT_Struct(m *structpb.Struct) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_Struct(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_Struct(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_Struct(m *structpb.Struct, dAtA []byte) (int, error) {
	size := SizeVT_Struct(m)
	return MarshalToSizedBufferVT_Struct(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Struct(m *structpb.Struct, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.Fields) > 0 {
		for k := range m.Fields {
			v := m.Fields[k]
			baseI := i
			size, err := MarshalToSizedBufferVT_Value(v, dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarint(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarint(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func MarshalVT_Value(m *structpb.Value) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_Value(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_Value(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_Value(m *structpb.Value, dAtA []byte) (int, error) {
	size := SizeVT_Value(m)
	return MarshalToSizedBufferVT_Value(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Value(m *structpb.Value, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if m.Kind != nil {
		var size int
		var err error
		switch t := m.Kind.(type) {
		case *structpb.Value_NullValue:
			size, err = MarshalToSizedBufferVT_Value_NullValue(t, dAtA[:i])
		case *structpb.Value_NumberValue:
			size, err = MarshalToSizedBufferVT_Value_NumberValue(t, dAtA[:i])
		case *structpb.Value_StringValue:
			size, err = MarshalToSizedBufferVT_Value_StringValue(t, dAtA[:i])
		case *structpb.Value_BoolValue:
			size, err = MarshalToSizedBufferVT_Value_BoolValue(t, dAtA[:i])
		case *structpb.Value_StructValue:
			size, err = MarshalToSizedBufferVT_Value_StructValue(t, dAtA[:i])
		case *structpb.Value_ListValue:
			size, err = MarshalToSizedBufferVT_Value_ListValue(t, dAtA[:i])
		}
		if err != nil {
			return 0, err
		}
		i -= size
	}
	return len(dAtA) - i, nil
}

func MarshalToVT_Value_NullValue(m *structpb.Value_NullValue, dAtA []byte) (int, error) {
	size := SizeVT_Value_NullValue(m)
	return MarshalToSizedBufferVT_Value_NullValue(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Value_NullValue(m *structpb.Value_NullValue, dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarint(dAtA, i, uint64(m.NullValue))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func MarshalToVT_Value_NumberValue(m *structpb.Value_NumberValue, dAtA []byte) (int, error) {
	size := SizeVT_Value_NumberValue(m)
	return MarshalToSizedBufferVT_Value_NumberValue(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Value_NumberValue(m *structpb.Value_NumberValue, dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NumberValue))))
	i--
	dAtA[i] = 0x11
	return len(dAtA) - i, nil
}
func MarshalToVT_Value_StringValue(m *structpb.Value_StringValue, dAtA []byte) (int, error) {
	size := SizeVT_Value_StringValue(m)
	return MarshalToSizedBufferVT_Value_StringValue(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Value_StringValue(m *structpb.Value_StringValue, dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarint(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func MarshalToVT_Value_BoolValue(m *structpb.Value_BoolValue, dAtA []byte) (int, error) {
	size := SizeVT_Value_BoolValue(m)
	return MarshalToSizedBufferVT_Value_BoolValue(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Value_BoolValue(m *structpb.Value_BoolValue, dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func MarshalToVT_Value_StructValue(m *structpb.Value_StructValue, dAtA []byte) (int, error) {
	size := SizeVT_Value_StructValue(m)
	return MarshalToSizedBufferVT_Value_StructValue(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Value_StructValue(m *structpb.Value_StructValue, dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StructValue != nil {
		size, err := MarshalToSizedBufferVT_Struct(m.StructValue, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func MarshalToVT_Value_ListValue(m *structpb.Value_ListValue, dAtA []byte) (int, error) {
	size := SizeVT_Value_ListValue(m)
	return MarshalToSizedBufferVT_Value_ListValue(m, dAtA[:size])
}

func MarshalToSizedBufferVT_Value_ListValue(m *structpb.Value_ListValue, dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ListValue != nil {
		size, err := MarshalToSizedBufferVT_ListValue(m.ListValue, dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarint(dAtA, i, uint64(size))
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func MarshalVT_ListValue(m *structpb.ListValue) (dAtA []byte, err error) {
	if m == nil {
		return nil, nil
	}
	size := SizeVT_ListValue(m)
	dAtA = make([]byte, size)
	n, err := MarshalToSizedBufferVT_ListValue(m, dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func MarshalToVT_ListValue(m *structpb.ListValue, dAtA []byte) (int, error) {
	size := SizeVT_ListValue(m)
	return MarshalToSizedBufferVT_ListValue(m, dAtA[:size])
}

func MarshalToSizedBufferVT_ListValue(m *structpb.ListValue, dAtA []byte) (int, error) {
	if m == nil {
		return 0, nil
	}
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if uf := m.ProtoReflect().GetUnknown(); uf != nil {
		i -= len(uf)
		copy(dAtA[i:], uf)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			size, err := MarshalToSizedBufferVT_Value(m.Values[iNdEx], dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarint(dAtA, i, uint64(size))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarint(dAtA []byte, offset int, v uint64) int {
	offset -= sov(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func SizeVT_Struct(m *structpb.Struct) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = SizeVT_Value(v)
			}
			l += 1 + sov(uint64(l))
			mapEntrySize := 1 + len(k) + sov(uint64(len(k))) + l
			n += mapEntrySize + 1 + sov(uint64(mapEntrySize))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_Value(m *structpb.Value) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != nil {
		switch t := m.Kind.(type) {
		case *structpb.Value_NullValue:
			n += SizeVT_Value_NullValue(t)
		case *structpb.Value_NumberValue:
			n += SizeVT_Value_NumberValue(t)
		case *structpb.Value_StringValue:
			n += SizeVT_Value_StringValue(t)
		case *structpb.Value_BoolValue:
			n += SizeVT_Value_BoolValue(t)
		case *structpb.Value_StructValue:
			n += SizeVT_Value_StructValue(t)
		case *structpb.Value_ListValue:
			n += SizeVT_Value_ListValue(t)
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func SizeVT_Value_NullValue(m *structpb.Value_NullValue) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sov(uint64(m.NullValue))
	return n
}
func SizeVT_Value_NumberValue(m *structpb.Value_NumberValue) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func SizeVT_Value_StringValue(m *structpb.Value_StringValue) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sov(uint64(l))
	return n
}
func SizeVT_Value_BoolValue(m *structpb.Value_BoolValue) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func SizeVT_Value_StructValue(m *structpb.Value_StructValue) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StructValue != nil {
		l = SizeVT_Struct(m.StructValue)
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func SizeVT_Value_ListValue(m *structpb.Value_ListValue) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListValue != nil {
		l = SizeVT_ListValue(m.ListValue)
		n += 1 + l + sov(uint64(l))
	}
	return n
}
func SizeVT_ListValue(m *structpb.ListValue) (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = SizeVT_Value(e)
			n += 1 + l + sov(uint64(l))
		}
	}
	n += len(m.ProtoReflect().GetUnknown())
	return n
}

func sov(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func soz(x uint64) (n int) {
	return sov(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func UnmarshalVT_Struct(m *structpb.Struct, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Struct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Struct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]*structpb.Value)
			}
			var mapkey string
			var mapvalue *structpb.Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLength
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLength
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLength
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLength
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &structpb.Value{}
					if err := UnmarshalVT_Value(mapvalue, dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skip(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLength
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_Value(m *structpb.Value, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullValue", wireType)
			}
			var v structpb.NullValue
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= structpb.NullValue(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kind = &structpb.Value_NullValue{NullValue: v}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Kind = &structpb.Value_NumberValue{NumberValue: float64(math.Float64frombits(v))}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = &structpb.Value_StringValue{StringValue: string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Kind = &structpb.Value_BoolValue{BoolValue: b}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StructValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Kind.(*structpb.Value_StructValue); ok {
				if err := UnmarshalVT_Struct(oneof.StructValue, dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &structpb.Struct{}
				if err := UnmarshalVT_Struct(v, dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Kind = &structpb.Value_StructValue{StructValue: v}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if oneof, ok := m.Kind.(*structpb.Value_ListValue); ok {
				if err := UnmarshalVT_ListValue(oneof.ListValue, dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
			} else {
				v := &structpb.ListValue{}
				if err := UnmarshalVT_ListValue(v, dAtA[iNdEx:postIndex]); err != nil {
					return err
				}
				m.Kind = &structpb.Value_ListValue{ListValue: v}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func UnmarshalVT_ListValue(m *structpb.ListValue, dAtA []byte) error {
	unknownFields := m.ProtoReflect().GetUnknown()
	unknownFieldsPreLen := len(unknownFields)
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLength
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLength
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &structpb.Value{})
			if err := UnmarshalVT_Value(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skip(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLength
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			unknownFields = append(unknownFields, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if len(unknownFields) > unknownFieldsPreLen {
		m.ProtoReflect().SetUnknown(unknownFields)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skip(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLength
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroup
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLength
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLength        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroup = fmt.Errorf("proto: unexpected end of group")
)
